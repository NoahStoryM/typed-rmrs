#+TITLE: Typed Racket Module for Revised Scheme
#+AUTHOR: Noah Ma
#+EMAIL: noahstorym@gmail.com

* Table of Contents                                       :TOC_5_gh:noexport:
- [[#项目概述][项目概述]]
  - [[#简介][简介]]
  - [[#核心特性][核心特性]]
  - [[#使用场景][使用场景]]
- [[#快速开始][快速开始]]
  - [[#纯-racket-用户][纯 Racket 用户]]
  - [[#混合用户][混合用户]]
- [[#架构设计][架构设计]]
  - [[#设计哲学][设计哲学]]
  - [[#多层模块体系][多层模块体系]]
    - [[#typed-rmrs-scheme][(typed rmrs scheme)]]
    - [[#typed-rmrs-racket][(typed rmrs racket)]]
    - [[#typed-rmrs-srfi][(typed rmrs srfi)]]
  - [[#编译流程][编译流程]]
- [[#技术细节][技术细节]]
  - [[#类型系统][类型系统]]
  - [[#类型擦除机制][类型擦除机制]]
  - [[#库组织规则][库组织规则]]
    - [[#核心库规则][核心库规则]]
    - [[#扁平化导出][扁平化导出]]
- [[#核心库版本历史][核心库版本历史]]
  - [[#第一版][第一版]]
  - [[#第二版][第二版]]
  - [[#第三版][第三版]]
  - [[#第四版][第四版]]
  - [[#第五版][第五版]]
  - [[#第六版][第六版]]
  - [[#第七版][第七版]]
- [[#附录][附录]]
  - [[#符号分类决策树][符号分类决策树]]
  - [[#冲突处理策略][冲突处理策略]]

* 项目概述
** 简介

RMRS（*Racket Module for Revised Scheme*）是一个让 Scheme 程序能以 Racket 风格编程的兼容层。它为 R6RS 与 R7RS-small 提供统一接口，并在兼容 SRFI 的基础上尽可能复现 Racket 的语义。

** 核心特性

- *统一接口* :: 为 R6RS 和 R7RS-small 提供一致的 API
- *Racket 风格* :: 使用 Racket 的命名约定（如 ~bytes~ 而非 ~bytevector~ ）
- *可选类型* :: 基于 Typed Racket 的渐进类型系统
- *模块化设计* :: 细粒度的模块划分，精确控制导入内容
- *跨平台编译* :: 开发时享受类型检查，部署时生成纯 Scheme 代码

** 使用场景

- 需要同一份代码能在多个 Scheme 实现运行
- 希望在 Scheme 项目中使用 Racket 的 API 设计
- 想要在开发时使用类型检查
- 需要混合使用 Racket 扩展和标准 Scheme 库

* 快速开始

以 r6rs 为例子

** 纯 Racket 用户

如果你希望完全使用 Racket 风格编程：

#+begin_src racket
#!r6rs

(import (typed r6rs no-check racket base))

(: factorial (-> Natural Natural))
(define (factorial n) (if (<= n 1) 1 (* n (factorial (- n 1)))))
(define data (bytes 1 2 3))
#+end_src

** 混合用户

如果需要精确控制导入内容，避免命名冲突：

#+begin_src racket
#!r6rs

(import (rnrs base)
        (typed r6rs no-check racket base bytes)
        (typed r6rs no-check racket base kernel))

(: process (-> Bytes Bytes))
(define (process input) (make-bytevector (bytes-length input) 12))
#+end_src

* 架构设计
** 设计哲学

RMRS 遵循以下核心原则：

1. *兼容性优先* :: 所有库编译后必须能在 R6RS 与 R7RS-small 环境下运行
3. *最小核心原则* :: 参考 R7RS-small，核心库只提供最基础的语义
4. *依赖最小化* :: 每个库的依赖尽可能少，避免循环依赖
6. *命名无冲突* :: 优先使用 Racket 版本，避免命名冲突
7. *明确来源* :: 符号的放置位置明确反映其来源（Racket, Scheme, SRFI）

** 多层模块体系

RMRS 采用多层模块结构，支持开发和多目标编译：

#+begin_example
开发环境 (类型检查开启):
  #!typed/rmrs/optional
  typed/rmrs/racket/...    ; Racket 特有功能
  typed/rmrs/scheme/...    ; Racket base 和 Scheme 交集
  typed/rmrs/srfi/...      ; SRFI 标准库

开发环境 (类型检查关闭):
  #!typed/rmrs/no-check
  typed/rmrs/racket/...    ; Racket 特有功能
  typed/rmrs/scheme/...    ; Racket base 和 Scheme 交集
  typed/rmrs/srfi/...      ; SRFI 标准库

编译目标 (类型擦除):
  #!r6rs
  typed/r6rs/racket/no-check/...    ; 编译到 R6RS
  typed/r6rs/scheme/no-check/...    ; 编译到 R6RS
  typed/r6rs/srfi/no-check/...      ; 编译到 R6RS

  #!r7rs
  typed/r7rs/racket/no-check/...    ; 编译到 R7RS
  typed/r7rs/scheme/no-check/...    ; 编译到 R7RS
  typed/r7rs/srfi/no-check/...      ; 编译到 R7RS
#+end_example

*** (typed rmrs scheme)

包含 Racket base 和 Scheme 的交集部分：
- 基础语法： ~lambda~, ~define~, ~let~, ~if~, ...
- 数据类型： ~char~, ~vector~, ~string~, ...
- 数值运算： ~+~, ~-~, ~*~, ~/~, ...
- 多值绑定： ~let-values~, ~case-lambda~, ...

*** (typed rmrs racket)

包含 Racket 特有的功能：
- 字节操作： ~bytes~, ~bytes-append~
- 可变对： ~mcons~, ~mcar~, ~mcdr~
- 类型标注： ~:~, ~ann~, ~cast~
- 控制流扩展： ~case/eqv~

*** (typed rmrs srfi)

包含 SRFI 标准库：
- SRFI-9：记录类型 (~define-record-type~)
- SRFI-155：Promise (~delay~, ~force~, ...)

** 编译流程

RMRS 的编译过程简单：

1. *命名空间替换* :: ~rmrs~ → ~r6rs~ 或 ~r7rs~
2. *合并导入* :: 将多条 ~import/typed~ 与 ~import~ 转为一条 ~import~
3. *库包装* :: 如果有 ~export~ ，自动包装为 ~library~ 形式
4. *语法转换* :: 转换 Racket 特有语法（如 bytes 字面量 ~#"abc"~ ）到目标 Scheme

* 技术细节
** 类型系统

RMRS 基于 Typed Racket 的类型系统：

- *开发时检查* :: 类型错误在开发阶段被发现
- *零运行时开销* :: 类型信息在宏展开后完全擦除
- *向后兼容* :: 编译后的代码是纯 Scheme

** 类型擦除机制

类型擦除通过宏系统实现，在 ~no-check~ 版本的模块中重新定义核心宏：

#+begin_src racket
(define-syntax :
  (syntax-rules ()
    [(_ name type-expr) (begin)]))
(define-syntax ann
  (syntax-rules ()
    [(_ expr type-expr) expr]))
(define-syntax cast
  (syntax-rules ()
    [(_ expr type-expr) expr]))
(define-syntax define-type
  (syntax-rules ()
    [(_ type type-expr) (begin)]))
#+end_src

** 库组织规则

*** 核心库规则
- 每个核心库必须提供 Racket、R6RS、R7RS-small 三个版本
- 参考 R7RS-small 的最小设计理念

*** 扁平化导出
聚合模块自动重导出所有子模块内容，提供便利性：

#+begin_example
(typed rmrs racket base data mpair)
  ↓ 自动导出
(typed rmrs racket base data mpair base)
(typed rmrs racket base data mpair mutator)
#+end_example

特殊规则：

- ~(typed rmrs racket base)~ 会导出 ~(typed rmrs scheme)~ 的全部内容
- ~(typed rmrs racket promise)~ 会导出 ~(typed rmrs srfi 155)~ 的全部内容

* 核心库版本历史
** 第一版

#+begin_src racket
'[(rmrs)
  [(rmrs racket)
   [(rmrs racket base)
    [(rmrs racket base case-lambda)
     case-λ]
    [(rmrs racket base data)
     [(rmrs racket base data bytes)
      [(rmrs racket base data bytes base)
       bytes                    bytes-append
       bytes-copy               bytes-length
       bytes-ref                bytes?
       make-bytes               byte-ready?]
      [(rmrs racket base data bytes conversion)
       string->bytes/utf-8      bytes->string/utf-8]
      [(rmrs racket base data bytes mutator)
       bytes-copy!              bytes-set!]]
     [(rmrs racket base data mpair)
      [(rmrs racket base data mpair base)
       mcar                     mcdr
       mcons                    mpair?]
      [(rmrs racket base data mpair mutator)
       set-mcar!                set-mcdr!]]]
    [(rmrs racket base lambda)
     λ]
    [(rmrs racket base port)
     eof                      get-output-bytes
     open-input-bytes         open-output-bytes
     peek-byte                read-bytes
     read-bytes!              read-byte
     write-bytes              write-byte]]
   [(rmrs racket case eqv)
    case/eqv]
   [(rmrs racket mpair)
    [(rmrs racket mpair base)
     make-mlist
     mappend                  massoc
     massq                    massv
     mfor-each                mlength
     mlist                    mlist-copy
     mlist-ref                mlist-tail
     mlist?                   mmap
     mmember                  mmemq
     mmemv                    mreverse]
    [(rmrs racket mpair conversion)
     mlist->string            mlist->vector
     string->mlist            vector->mlist]
    [(rmrs racket mpair mutator)
     mlist-set!]
    [(rmrs racket mpair cxr)
     mcaar                    mcadr
     mcdar                    mcddr
     mcaaar                   mcaadr
     mcadar                   mcaddr
     mcdaar                   mcdadr
     mcddar                   mcdddr
     mcaaaar                  mcaaadr
     mcaadar                  mcaaddr
     mcadaar                  mcadadr
     mcaddar                  mcadddr
     mcdaaar                  mcdaadr
     mcdadar                  mcdaddr
     mcddaar                  mcddadr
     mcdddar                  mcddddr]]]
  [(rmrs scheme)
   [(rmrs scheme base)
    [(rmrs scheme base continuation)
     call-with-current-continuation
     call/cc                  dynamic-wind]
    [(rmrs scheme base condition)
     cond                     unless
     when]
    [(rmrs scheme base data)
     [(rmrs scheme base data boolean)
      and                      boolean=?
      boolean?                 not
      or]
     [(rmrs scheme base data character)
      char<=?                  char<?
      char=?                   char>=?
      char>?                   char?]
     [(rmrs scheme base data conversion)
      char->integer            integer->char
      number->string           string->number
      string->symbol           string->vector
      symbol->string           vector->string]
     [(rmrs scheme base data null)
      null?]
     [(rmrs scheme base data number)
      *                        +
      -                        /
      <                        <=
      =                        >
      >=                       abs
      ceiling                  complex?
      denominator              even?
      exact                    exact-integer-sqrt
      exact-integer?           exact?
      expt                     floor
      floor-quotient           floor-remainder
      floor/                   gcd
      inexact                  inexact?
      integer?                 lcm
      max                      min
      modulo                   negative?
      number?                  numerator
      odd?                     positive?
      quotient                 rational?
      rationalize              real?
      remainder                round
      square                   truncate
      truncate-quotient        truncate-remainder
      truncate/                zero?]
     [(rmrs scheme base data string)
      [(rmrs scheme base data string base)
       make-string              string
       string-append            string-copy
       string-for-each          string-length
       string-map               string-ref
       string<=?                string<?
       string=?                 string>=?
       string>?                 string?
       substring]
      [(rmrs scheme base data string mutator)
       string-copy!             string-fill!
       string-set!]]
     [(rmrs scheme base data symbol)
      symbol=?                 symbol?]
     [(rmrs scheme base data vector)
      [(rmrs scheme base data vector base)
       make-vector              vector
       vector-append            vector-copy
       vector-for-each          vector-length
       vector-map               vector-ref
       vector?]
      [(rmrs scheme base data vector mutator)
       vector-copy!             vector-fill!
       vector-set!]]]
    [(rmrs scheme base exception)
     error                    error-object-irritants
     error-object-message     error-object?
     file-error?              read-error?]
    [(rmrs scheme base include)
     include                  include-ci]
    [(rmrs scheme base kernel)
     begin                    define
     eq?                      equal?
     eqv?                     if
     lambda                   quasiquote
     quote                    unquote
     unquote-splicing]
    [(rmrs scheme base let)
     let                      let*
     letrec                   letrec*]
    [(rmrs scheme base literal)
     ...                      =>
     _                        else]
    [(rmrs scheme base loop)
     do]
    [(rmrs scheme base macro)
     define-syntax            let-syntax
     letrec-syntax            syntax-error
     syntax-rules]
    [(rmrs scheme base mutator)
     set!]
    [(rmrs scheme base port)
     binary-port?             call-with-port
     char-ready?              close-input-port
     close-output-port        close-port
     current-error-port       current-input-port
     current-output-port      eof-object?
     flush-output-port        input-port-open?
     input-port?              newline
     output-port-open?        output-port?
     peek-char                port?
     read-char                read-line
     read-string              textural-port?
     write-char               write-string]
    [(rmrs scheme base procedure)
     apply                    procedure?]
    [(rmrs scheme base raise)
     guard                    raise
     raise-continuable        with-exception-handler]
    [(rmrs scheme base values)
     call-with-values         define-values
     let-values               let*-values
     values]]
   [(rmrs scheme case-lambda)
    case-lambda]
   [(rmrs scheme char)
    char-alphabetic?         char-ci<=?
    char-ci<?                char-ci=?
    char-ci>=?               char-ci>?
    char-downcase            char-foldcase
    char-lower-case?         char-numeric?
    char-upcase              char-upper-case?
    char-whitespace?         digit-value
    string-ci<=?             string-ci<?
    string-ci=?              string-ci>=?
    string-ci>?              string-downcase
    string-foldcase          string-upcase]
   [(rmrs scheme complex)
    angle                    imag-part
    magnitude                make-polar
    make-rectangular         real-part]
   [(rmrs scheme eval)
    environment              eval]
   [(rmrs scheme file)
    call-with-input-file     call-with-output-file
    delete-file              file-exists?
    open-binary-input-file   open-binary-output-file
    open-input-file          open-output-file
    with-input-from-file     with-output-to-file]
   [(rmrs scheme inexact)
    acos                     asin
    atan                     cos
    exp                      finite?
    infinite?                log
    nan?                     sin
    sqrt                     tan]
   [(rmrs scheme load)
    load]
   [(rmrs scheme process-context)
    command-line             emergency-exit
    exit                     get-environment-variable
    get-environment-variables]
   [(rmrs scheme read)
    read]
   [(rmrs scheme repl)
    interaction-environment]
   [(rmrs scheme time)
    current-jiffy            current-second
    jiffies-per-second]
   [(rmrs scheme write)
    display                  write
    write-shared             write-simple]]
  [(rmrs srfi)
   [(rmrs srfi srfi-0)
    cond-expand              features]
   [(rmrs srfi srfi-6)
    open-input-string        open-output-string
    get-output-string]
   [(rmrs srfi srfi-9)
    define-record-type]
   [(rmrs srfi srfi-39)
    make-parameter           parameterize]
   [(rmrs srfi srfi-155)
    delay                    delay-force
    force                    make-promise
    promise?]]]
#+end_src

** 第二版

#+begin_src racket
'[(rmrs)
  [(rmrs racket)
   [(rmrs racket base)
    [(rmrs racket base case-lambda)
     case-λ]
    [(rmrs racket base data)
     [(rmrs racket base data bytes)
      [(rmrs racket base data bytes base)
       bytes                    bytes-append
       bytes-copy               bytes-length
       bytes-ref                bytes?
       make-bytes]
      [(rmrs racket base data bytes conversion)
       string->bytes/utf-8      bytes->string/utf-8]
      [(rmrs racket base data bytes mutator)
       bytes-copy!              bytes-set!]]
     [(rmrs racket base data mpair)
      [(rmrs racket base data mpair base)
       mcar                     mcdr
       mcons                    mpair?]
      [(rmrs racket base data mpair mutator)
       set-mcar!                set-mcdr!]]]
    [(rmrs racket base exception)
     exn-irritants            exn-message
     exn:fail?                exn:fail:filesystem?
     exn:fail:read?]
    [(rmrs racket base lambda)
     λ]
    [(rmrs racket base port)
     eof                      flush-output
     get-output-bytes         open-input-bytes
     open-output-bytes        peek-byte
     port-closed?             read-bytes
     read-bytes!              read-byte
     string-port?             write-bytes
     write-byte]
    [(rmrs racket base date)
     current-milliseconds     current-seconds]]
   [(rmrs racket case eqv)
    case/eqv]
   [(rmrs racket mpair)
    [(rmrs racket mpair base)
     make-mlist
     mappend                  massoc
     massq                    massv
     mfor-each                mlength
     mlist                    mlist-copy
     mlist-ref                mlist-tail
     mlist?                   mmap
     mmember                  mmemq
     mmemv                    mreverse]
    [(rmrs racket mpair conversion)
     mlist->string            mlist->vector
     string->mlist            vector->mlist]
    [(rmrs racket mpair mutator)
     mlist-set!]
    [(rmrs racket mpair cxr)
     mcaar                    mcadr
     mcdar                    mcddr
     mcaaar                   mcaadr
     mcadar                   mcaddr
     mcdaar                   mcdadr
     mcddar                   mcdddr
     mcaaaar                  mcaaadr
     mcaadar                  mcaaddr
     mcadaar                  mcadadr
     mcaddar                  mcadddr
     mcdaaar                  mcdaadr
     mcdadar                  mcdaddr
     mcddaar                  mcddadr
     mcdddar                  mcddddr]]]
  [(rmrs scheme)
   [(rmrs scheme base)
    [(rmrs scheme base condition)
     cond                     unless
     when]
    [(rmrs scheme base continuation)
     call-with-current-continuation
     call/cc                  dynamic-wind]
    [(rmrs scheme base data)
     [(rmrs scheme base data boolean)
      and                      boolean=?
      boolean?                 not
      or]
     [(rmrs scheme base data character)
      char<=?                  char<?
      char=?                   char>=?
      char>?                   char?]
     [(rmrs scheme base data conversion)
      char->integer            integer->char
      number->string           string->number
      string->symbol           symbol->string]
     [(rmrs scheme base data null)
      null?]
     [(rmrs scheme base data number)
      *                        +
      -                        /
      <                        <=
      =                        >
      >=                       abs
      ceiling                  complex?
      denominator              even?
      exact->inexact           exact-integer?
      exact?                   expt
      floor                    gcd
      inexact->exact           inexact?
      integer?                 lcm
      max                      min
      modulo                   negative?
      number?                  numerator
      odd?                     positive?
      quotient                 rational?
      rationalize              real?
      remainder                round
      truncate                 zero?]
     [(rmrs scheme base data string)
      [(rmrs scheme base data string base)
       make-string              string
       string-append            string-copy
       string-length            string-ref
       string<=?                string<?
       string=?                 string>=?
       string>?                 string?
       substring]
      [(rmrs scheme base data string mutator)
       string-copy!             string-fill!
       string-set!]]
     [(rmrs scheme base data symbol)
      symbol=?                 symbol?]
     [(rmrs scheme base data vector)
      [(rmrs scheme base data vector base)
       make-vector              vector
       vector-append            vector-copy
       vector-length            vector-ref
       vector?]
      [(rmrs scheme base data vector mutator)
       vector-copy!             vector-fill!
       vector-set!]]]
    [(rmrs scheme base kernel)
     begin                    define
     eq?                      equal?
     eqv?                     if
     lambda                   quasiquote
     quote                    unquote
     unquote-splicing]
    [(rmrs scheme base let)
     let                      let*
     letrec                   letrec*]
    [(rmrs scheme base literal)
     ...                      =>
     _                        else]
    [(rmrs scheme base loop)
     do]
    [(rmrs scheme base macro)
     define-syntax            let-syntax
     letrec-syntax            syntax-rules]
    [(rmrs scheme base mutator)
     set!]
    [(rmrs scheme base port)
     close-input-port         close-output-port
     current-error-port       current-input-port
     current-output-port      eof-object?
     input-port?              newline
     output-port?             peek-char
     port?                    read-char
     read-line                read-string
     write-char               write-string]
    [(rmrs scheme base procedure)
     apply                    procedure?]
    [(rmrs scheme base values)
     call-with-values         values]]
   [(rmrs scheme char)
    char-alphabetic?         char-ci<=?
    char-ci<?                char-ci=?
    char-ci>=?               char-ci>?
    char-downcase            char-foldcase
    char-lower-case?         char-numeric?
    char-upcase              char-upper-case?
    char-whitespace?         string-ci<=?
    string-ci<?              string-ci=?
    string-ci>=?             string-ci>?
    string-downcase          string-foldcase
    string-upcase]
   [(rmrs scheme complex)
    angle                    imag-part
    magnitude                make-polar
    make-rectangular         real-part]
   [(rmrs scheme eval)
    environment              eval]
   [(rmrs scheme file)
    call-with-input-file     call-with-output-file
    delete-file              file-exists?
    open-input-file          open-output-file
    with-input-from-file     with-output-to-file]
   [(rmrs scheme inexact)
    acos                     asin
    atan                     cos
    exp                      infinite?
    log                      nan?
    sin                      sqrt
    tan]
   [(rmrs scheme process-context)
    command-line             exit]
   [(rmrs scheme read)
    read]
   [(rmrs scheme write)
    display                  write]]
  [(rmrs srfi)
   [(rmrs srfi srfi-6)
    open-input-string        open-output-string
    get-output-string]
   [(rmrs srfi srfi-9)
    define-record-type]
   [(rmrs srfi srfi-11)
    let-values               let*-values]
   [(rmrs srfi srfi-16)
    case-lambda]
   [(rmrs srfi srfi-23)
    error]
   [(rmrs srfi srfi-34)
    guard                    raise
    with-exception-handler]
   [(rmrs srfi srfi-155)
    delay                    delay-force
    force                    make-promise
    promise?]]]
#+end_src

** 第三版

#+begin_src racket
'[(typed rmrs optional)
  [(typed rmrs optional racket)
   [(typed rmrs optional racket base)
    [(typed rmrs optional racket base case-lambda)
     case-λ]
    [(typed rmrs optional racket base data)
     [(typed rmrs optional racket base data bytes)
      [(typed rmrs optional racket base data bytes base)
       bytes                    bytes-append
       bytes-copy               bytes-length
       bytes-ref                bytes?
       make-bytes]
      [(typed rmrs optional racket base data bytes conversion)
       string->bytes/utf-8      bytes->string/utf-8]
      [(typed rmrs optional racket base data bytes mutator)
       bytes-copy!              bytes-set!]]
     [(typed rmrs optional racket base data mpair)
      [(typed rmrs optional racket base data mpair base)
       mcar                     mcdr
       mcons                    mpair?]
      [(typed rmrs optional racket base data mpair mutator)
       set-mcar!                set-mcdr!]]]
    [(typed rmrs optional racket base exception)
     exn-irritants            exn-message
     exn:fail?                exn:fail:filesystem?
     exn:fail:read?]
    [(typed rmrs optional racket base lambda)
     λ]
    [(typed rmrs optional racket base port)
     eof                      flush-output
     get-output-bytes         open-input-bytes
     open-output-bytes        peek-byte
     port-closed?             read-bytes
     read-bytes!              read-byte
     string-port?             write-bytes
     write-byte]
    [(typed rmrs optional racket base date)
     current-milliseconds     current-seconds]]
   [(typed rmrs optional racket case eqv)
    case/eqv]
   [(typed rmrs optional racket mpair)
    [(typed rmrs optional racket mpair base)
     make-mlist
     mappend                  massoc
     massq                    massv
     mfor-each                mlength
     mlist                    mlist-copy
     mlist-ref                mlist-tail
     mlist?                   mmap
     mmember                  mmemq
     mmemv                    mreverse]
    [(typed rmrs optional racket mpair conversion)
     mlist->string            mlist->vector
     string->mlist            vector->mlist]
    [(typed rmrs optional racket mpair mutator)
     mlist-set!]
    [(typed rmrs optional racket mpair cxr)
     mcaar                    mcadr
     mcdar                    mcddr
     mcaaar                   mcaadr
     mcadar                   mcaddr
     mcdaar                   mcdadr
     mcddar                   mcdddr
     mcaaaar                  mcaaadr
     mcaadar                  mcaaddr
     mcadaar                  mcadadr
     mcaddar                  mcadddr
     mcdaaar                  mcdaadr
     mcdadar                  mcdaddr
     mcddaar                  mcddadr
     mcdddar                  mcddddr]]]
  [(typed rmrs optional scheme)
   [(typed rmrs optional scheme base)
    [(typed rmrs optional scheme base condition)
     =>                       cond
     else                     unless
     when]
    [(typed rmrs optional scheme base continuation)
     call-with-current-continuation
     call/cc                  dynamic-wind]
    [(typed rmrs optional scheme base data)
     [(typed rmrs optional scheme base data boolean)
      and                      boolean=?
      boolean?                 not
      or]
     [(typed rmrs optional scheme base data character)
      char<=?                  char<?
      char=?                   char>=?
      char>?                   char?]
     [(typed rmrs optional scheme base data conversion)
      char->integer            integer->char
      number->string           string->number
      string->symbol           symbol->string]
     [(typed rmrs optional scheme base data null)
      null?]
     [(typed rmrs optional scheme base data number)
      *                        +
      -                        /
      <                        <=
      =                        >
      >=                       abs
      ceiling                  complex?
      denominator              even?
      exact->inexact           exact-integer?
      exact?                   expt
      floor                    gcd
      inexact->exact           inexact?
      integer?                 lcm
      max                      min
      modulo                   negative?
      number?                  numerator
      odd?                     positive?
      quotient                 rational?
      rationalize              real?
      remainder                round
      truncate                 zero?]
     [(typed rmrs optional scheme base data string)
      [(typed rmrs optional scheme base data string base)
       make-string              string
       string-append            string-copy
       string-length            string-ref
       string<=?                string<?
       string=?                 string>=?
       string>?                 string?
       substring]
      [(typed rmrs optional scheme base data string mutator)
       string-copy!             string-fill!
       string-set!]]
     [(typed rmrs optional scheme base data symbol)
      symbol=?                 symbol?]
     [(typed rmrs optional scheme base data vector)
      [(typed rmrs optional scheme base data vector base)
       make-vector              vector
       vector-append            vector-copy
       vector-length            vector-ref
       vector?]
      [(typed rmrs optional scheme base data vector mutator)
       vector-copy!             vector-fill!
       vector-set!]]]
    [(typed rmrs optional scheme base kernel)
     begin                    define
     eq?                      equal?
     eqv?                     if
     lambda                   quasiquote
     quote                    unquote
     unquote-splicing]
    [(typed rmrs optional scheme base let)
     let                      let*
     letrec                   letrec*]
    [(typed rmrs optional scheme base loop)
     do]
    [(typed rmrs optional scheme base macro)
     ...                      _
     define-syntax            let-syntax
     letrec-syntax            syntax-rules]
    [(typed rmrs optional scheme base mutator)
     set!]
    [(typed rmrs optional scheme base port)
     close-input-port         close-output-port
     current-error-port       current-input-port
     current-output-port      eof-object?
     input-port?              newline
     output-port?             peek-char
     port?                    read-char
     read-line                read-string
     write-char               write-string]
    [(typed rmrs optional scheme base procedure)
     apply                    procedure?]
    [(typed rmrs optional scheme base values)
     call-with-values         values]]
   [(typed rmrs optional scheme char)
    char-alphabetic?         char-ci<=?
    char-ci<?                char-ci=?
    char-ci>=?               char-ci>?
    char-downcase            char-foldcase
    char-lower-case?         char-numeric?
    char-upcase              char-upper-case?
    char-whitespace?         string-ci<=?
    string-ci<?              string-ci=?
    string-ci>=?             string-ci>?
    string-downcase          string-foldcase
    string-upcase]
   [(typed rmrs optional scheme complex)
    angle                    imag-part
    magnitude                make-polar
    make-rectangular         real-part]
   [(typed rmrs optional scheme eval)
    environment              eval]
   [(typed rmrs optional scheme file)
    call-with-input-file     call-with-output-file
    delete-file              file-exists?
    open-input-file          open-output-file
    with-input-from-file     with-output-to-file]
   [(typed rmrs optional scheme inexact)
    acos                     asin
    atan                     cos
    exp                      infinite?
    log                      nan?
    sin                      sqrt
    tan]
   [(typed rmrs optional scheme process-context)
    command-line             exit]
   [(typed rmrs optional scheme read)
    read]
   [(typed rmrs optional scheme write)
    display                  write]]
  [(typed rmrs optional srfi)
   [(typed rmrs optional srfi srfi-6)
    open-input-string        open-output-string
    get-output-string]
   [(typed rmrs optional srfi srfi-9)
    define-record-type]
   [(typed rmrs optional srfi srfi-11)
    let-values               let*-values]
   [(typed rmrs optional srfi srfi-16)
    case-lambda]
   [(typed rmrs optional srfi srfi-23)
    error]
   [(typed rmrs optional srfi srfi-34)
    guard                    raise
    with-exception-handler]
   [(typed rmrs optional srfi srfi-155)
    delay                    delay-force
    force                    make-promise
    promise?]]
  [(typed rmrs optional type)
   :                        ann
   cast                     define-type]]
#+end_src

** 第四版

#+begin_src racket
'[(rmrs typed)
  [(rmrs typed racket optional)
   [(rmrs typed racket optional base)
    [(rmrs typed racket optional base data)
     [(rmrs typed racket optional base data bytes)
      [(rmrs typed racket optional base data bytes base)
       bytes                    bytes-copy
       bytes-length             bytes-ref
       bytes?                   make-bytes]
      [(rmrs typed racket optional base data bytes conversion)
       string->bytes/utf-8      bytes->string/utf-8]
      [(rmrs typed racket optional base data bytes mutator)
       bytes-copy!              bytes-set!]]
     [(rmrs typed racket optional base data mpair)
      [(rmrs typed racket optional base data mpair base)
       mcar                     mcdr
       mcons                    mpair?]
      [(rmrs typed racket optional base data mpair mutator)
       set-mcar!                set-mcdr!]]]
    [(rmrs typed racket optional base exception)
     call-with-exception-handler
     exn-irritants            exn-message
     exn:fail?                exn:fail:filesystem?
     exn:fail:read?           with-handlers
     with-handlers*]
    [(rmrs typed racket optional base kernel)
     :                        λ
     ann                      case-λ
     cast                     define-type]
    [(rmrs typed racket optional base port)
     eof                      flush-output
     get-output-bytes         open-input-bytes
     open-output-bytes        peek-byte
     port-closed?             read-bytes
     read-bytes!              read-byte
     string-port?             write-bytes
     write-byte]
    [(rmrs typed racket optional base date)
     current-milliseconds     current-seconds]]
   [(rmrs typed racket optional case eqv)
    case/eqv]
   [(rmrs typed racket optional promise)
    lazy]
   [(rmrs typed racket optional mpair)
    [(rmrs typed racket optional mpair base)
     make-mlist
     mappend                  massoc
     massq                    massv
     mfor-each                mlength
     mlist                    mlist-copy
     mlist-ref                mlist-tail
     mlist?                   mmap
     mmember                  mmemq
     mmemv                    mreverse]
    [(rmrs typed racket optional mpair conversion)
     mlist->string            mlist->vector
     string->mlist            vector->mlist]
    [(rmrs typed racket optional mpair mutator)
     mlist-set!]
    [(rmrs typed racket optional mpair cxr)
     mcaar                    mcadr
     mcdar                    mcddr
     mcaaar                   mcaadr
     mcadar                   mcaddr
     mcdaar                   mcdadr
     mcddar                   mcdddr
     mcaaaar                  mcaaadr
     mcaadar                  mcaaddr
     mcadaar                  mcadadr
     mcaddar                  mcadddr
     mcdaaar                  mcdaadr
     mcdadar                  mcdaddr
     mcddaar                  mcddadr
     mcdddar                  mcddddr]]]
  [(rmrs typed scheme optional)
   [(rmrs typed scheme optional base)
    [(rmrs typed scheme optional base condition)
     =>                       cond
     else                     unless
     when]
    [(rmrs typed scheme optional base continuation)
     call-with-current-continuation
     call/cc                  dynamic-wind]
    [(rmrs typed scheme optional base data)
     [(rmrs typed scheme optional base data boolean)
      and                      boolean=?
      boolean?                 not
      or]
     [(rmrs typed scheme optional base data character)
      char<=?                  char<?
      char=?                   char>=?
      char>?                   char?]
     [(rmrs typed scheme optional base data conversion)
      char->integer            integer->char
      number->string           string->number
      string->symbol           symbol->string]
     [(rmrs typed scheme optional base data null)
      null?]
     [(rmrs typed scheme optional base data number)
      *                        +
      -                        /
      <                        <=
      =                        >
      >=                       abs
      ceiling                  complex?
      denominator              even?
      exact->inexact           exact-integer?
      exact?                   expt
      floor                    gcd
      inexact->exact           inexact?
      integer?                 lcm
      max                      min
      modulo                   negative?
      number?                  numerator
      odd?                     positive?
      quotient                 rational?
      rationalize              real?
      remainder                round
      truncate                 zero?]
     [(rmrs typed scheme optional base data string)
      [(rmrs typed scheme optional base data string base)
       make-string              string
       string-append            string-copy
       string-length            string-ref
       string<=?                string<?
       string=?                 string>=?
       string>?                 string?
       substring]
      [(rmrs typed scheme optional base data string mutator)
       string-copy!             string-fill!
       string-set!]]
     [(rmrs typed scheme optional base data symbol)
      symbol=?                 symbol?]
     [(rmrs typed scheme optional base data vector)
      [(rmrs typed scheme optional base data vector base)
       make-vector              vector
       vector-append            vector-copy
       vector-length            vector-ref
       vector?]
      [(rmrs typed scheme optional base data vector mutator)
       vector-copy!             vector-fill!
       vector-set!]]]
    [(rmrs typed scheme optional base exception)
     error                    raise]
    [(rmrs typed scheme optional base kernel)
     begin                    case-lambda
     define                   eq?
     equal?                   eqv?
     if                       lambda
     quasiquote               quote
     unquote                  unquote-splicing]
    [(rmrs typed scheme optional base let)
     let                      let*
     letrec                   letrec*]
    [(rmrs typed scheme optional base loop)
     do]
    [(rmrs typed scheme optional base macro)
     ...                      _
     define-syntax            let-syntax
     letrec-syntax            syntax-rules]
    [(rmrs typed scheme optional base mutator)
     set!]
    [(rmrs typed scheme optional base port)
     close-input-port         close-output-port
     current-error-port       current-input-port
     current-output-port      eof-object?
     get-output-string        input-port?
     newline                  open-input-string
     open-output-string       output-port?
     peek-char                port?
     read-char                read-line
     read-string              write-char
     write-string]
    [(rmrs typed scheme optional base procedure)
     apply                    procedure?]
    [(rmrs typed scheme optional base values)
     call-with-values         let-values
     let*-values              values]]
   [(rmrs typed scheme optional char)
    char-alphabetic?         char-ci<=?
    char-ci<?                char-ci=?
    char-ci>=?               char-ci>?
    char-downcase            char-foldcase
    char-lower-case?         char-numeric?
    char-upcase              char-upper-case?
    char-whitespace?         string-ci<=?
    string-ci<?              string-ci=?
    string-ci>=?             string-ci>?
    string-downcase          string-foldcase
    string-upcase]
   [(rmrs typed scheme optional complex)
    angle                    imag-part
    magnitude                make-polar
    make-rectangular         real-part]
   [(rmrs typed scheme optional eval)
    environment              eval
    interaction-environment]
   [(rmrs typed scheme optional file)
    call-with-input-file     call-with-output-file
    delete-file              file-exists?
    open-input-file          open-output-file
    with-input-from-file     with-output-to-file]
   [(rmrs typed scheme optional inexact)
    acos                     asin
    atan                     cos
    exp                      infinite?
    log                      nan?
    sin                      sqrt
    tan]
   [(rmrs typed scheme optional process-context)
    command-line             exit]
   [(rmrs typed scheme optional read)
    read]
   [(rmrs typed scheme optional write)
    display                  write]]
  [(rmrs typed srfi optional)
   [(rmrs typed srfi optional srfi-9)
    define-record-type]
   [(rmrs typed srfi optional srfi-155)
    delay                    delay-force
    force                    make-promise
    promise?]]]
#+end_src

** 第五版

#+begin_src racket
'[(rmrs typed)
  [(rmrs typed racket optional)
   [(rmrs typed racket optional base)
    [(rmrs typed racket optional base data)
     [(rmrs typed racket optional base data bytes)
      [(rmrs typed racket optional base data bytes base)
       bytes                    bytes-copy
       bytes-length             bytes-ref
       bytes?                   make-bytes]
      [(rmrs typed racket optional base data bytes conversion)
       string->bytes/utf-8      bytes->string/utf-8]
      [(rmrs typed racket optional base data bytes mutator)
       bytes-copy!              bytes-set!]]
     [(rmrs typed racket optional base data void)
      void                     void?]]
    [(rmrs typed racket optional base exception)
     call-with-exception-handler
     exn-irritants            exn-message
     exn:fail?                exn:fail:filesystem?
     exn:fail:read?           with-handlers
     with-handlers*]
    [(rmrs typed racket optional base kernel)
     :                        λ
     ann                      case-λ
     cast                     define-type]
    [(rmrs typed racket optional base port)
     eof                      flush-output
     get-output-bytes         open-input-bytes
     open-output-bytes        peek-byte
     port-closed?             read-bytes
     read-bytes!              read-byte
     string-port?             write-bytes
     write-byte]
    [(rmrs typed racket optional base date)
     current-milliseconds     current-seconds]]
   [(rmrs typed racket optional case eqv)
    case/eqv]
   [(rmrs typed racket optional promise lazy)
    lazy]
   [(rmrs typed racket optional unsafe ops data pair mutator)
    unsafe-set-immutable-car!
    unsafe-set-immutable-cdr!]]
  [(rmrs typed scheme optional)
   [(rmrs typed scheme optional base)
    [(rmrs typed scheme optional base condition)
     =>                       cond
     else                     unless
     when]
    [(rmrs typed scheme optional base continuation)
     call-with-current-continuation
     call/cc                  dynamic-wind]
    [(rmrs typed scheme optional base data)
     [(rmrs typed scheme optional base data boolean)
      and                      boolean=?
      boolean?                 not
      or]
     [(rmrs typed scheme optional base data character)
      char<=?                  char<?
      char=?                   char>=?
      char>?                   char?]
     [(rmrs typed scheme optional base data conversion)
      char->integer            integer->char
      list->string             list->vector
      number->string           string->list
      string->number           string->symbol
      symbol->string           vector->list]
     [(rmrs typed scheme optional base data list)
      append                   assoc
      assq                     assv
      car                      cdr
      cons                     for-each
      length                   list
      list-ref                 list-tail
      list?                    map
      member                   memq
      memv                     null?
      pair?                    reverse]
     [(rmrs typed scheme optional base data number)
      *                        +
      -                        /
      <                        <=
      =                        >
      >=                       abs
      ceiling                  complex?
      denominator              even?
      exact->inexact           exact-integer?
      exact?                   expt
      floor                    gcd
      inexact->exact           inexact?
      integer?                 lcm
      max                      min
      modulo                   negative?
      number?                  numerator
      odd?                     positive?
      quotient                 rational?
      rationalize              real?
      remainder                round
      truncate                 zero?]
     [(rmrs typed scheme optional base data string)
      [(rmrs typed scheme optional base data string base)
       make-string              string
       string-append            string-copy
       string-length            string-ref
       string<=?                string<?
       string=?                 string>=?
       string>?                 string?
       substring]
      [(rmrs typed scheme optional base data string mutator)
       string-copy!             string-fill!
       string-set!]]
     [(rmrs typed scheme optional base data symbol)
      symbol=?                 symbol?]
     [(rmrs typed scheme optional base data vector)
      [(rmrs typed scheme optional base data vector base)
       make-vector              vector
       vector-append            vector-copy
       vector-length            vector-ref
       vector?]
      [(rmrs typed scheme optional base data vector mutator)
       vector-copy!             vector-fill!
       vector-set!]]]
    [(rmrs typed scheme optional base exception)
     error                    raise]
    [(rmrs typed scheme optional base kernel)
     begin                    case-lambda
     define                   eq?
     equal?                   eqv?
     if                       lambda
     quasiquote               quote
     unquote                  unquote-splicing]
    [(rmrs typed scheme optional base let)
     let                      let*
     letrec                   letrec*]
    [(rmrs typed scheme optional base loop)
     do]
    [(rmrs typed scheme optional base macro)
     ...                      _
     define-syntax            let-syntax
     letrec-syntax            syntax-rules]
    [(rmrs typed scheme optional base mutator)
     set!]
    [(rmrs typed scheme optional base port)
     close-input-port         close-output-port
     current-error-port       current-input-port
     current-output-port      eof-object?
     get-output-string        input-port?
     newline                  open-input-string
     open-output-string       output-port?
     peek-char                port?
     read-char                read-line
     read-string              write-char
     write-string]
    [(rmrs typed scheme optional base procedure)
     apply                    procedure?]
    [(rmrs typed scheme optional base values)
     call-with-values         let-values
     let*-values              values]]
   [(rmrs typed scheme optional char)
    char-alphabetic?         char-ci<=?
    char-ci<?                char-ci=?
    char-ci>=?               char-ci>?
    char-downcase            char-foldcase
    char-lower-case?         char-numeric?
    char-upcase              char-upper-case?
    char-whitespace?         string-ci<=?
    string-ci<?              string-ci=?
    string-ci>=?             string-ci>?
    string-downcase          string-foldcase
    string-upcase]
   [(rmrs typed scheme optional complex)
    angle                    imag-part
    magnitude                make-polar
    make-rectangular         real-part]
   [(rmrs typed scheme optional cxr)
    caar                      cadr
    cdar                      cddr
    caaar                     caadr
    cadar                     caddr
    cdaar                     cdadr
    cddar                     cdddr
    caaaar                    caaadr
    caadar                    caaddr
    cadaar                    cadadr
    caddar                    cadddr
    cdaaar                    cdaadr
    cdadar                    cdaddr
    cddaar                    cddadr
    cdddar                    cddddr]
   [(rmrs typed scheme optional eval)
    environment              eval
    interaction-environment]
   [(rmrs typed scheme optional file)
    call-with-input-file     call-with-output-file
    delete-file              file-exists?
    open-input-file          open-output-file
    with-input-from-file     with-output-to-file]
   [(rmrs typed scheme optional inexact)
    acos                     asin
    atan                     cos
    exp                      infinite?
    log                      nan?
    sin                      sqrt
    tan]
   [(rmrs typed scheme optional process-context)
    command-line             exit]
   [(rmrs typed scheme optional read)
    read]
   [(rmrs typed scheme optional write)
    display                  write]]
  [(rmrs typed srfi optional)
   [(rmrs typed srfi optional srfi-9)
    define-record-type]
   [(rmrs typed srfi optional srfi-155)
    delay                    delay-force
    force                    make-promise
    promise?]]]
#+end_src

** 第六版

#+begin_src racket
'[(typed rmrs)
  [(typed rmrs racket)
   [(typed rmrs racket base)
    [(typed rmrs racket base cmdline)
     current-command-line-arguments]
    [(typed rmrs racket base data)
     [(typed rmrs racket base data bytes)
      [(typed rmrs racket base data bytes base)
       bytes                    bytes-copy
       bytes-length             bytes-ref
       bytes?                   make-bytes]
      [(typed rmrs racket base data bytes conversion)
       string->bytes/utf-8      bytes->string/utf-8]
      [(typed rmrs racket base data bytes mutator)
       bytes-copy!              bytes-set!]]
     [(typed rmrs racket base data void)
      void                     void?]]
    [(typed rmrs racket base exception)
     call-with-exception-handler
     exn-irritants            exn-message
     exn:fail?                exn:fail:filesystem?
     exn:fail:read?           with-handlers
     with-handlers*]
    [(typed rmrs racket base kernel)
     :                        λ
     ann                      case-λ
     cast                     define-type]
    [(typed rmrs racket base port)
     eof                      flush-output
     get-output-bytes         open-input-bytes
     open-output-bytes        peek-byte
     port-closed?             read-bytes
     read-bytes!              read-byte
     string-port?             write-bytes
     write-byte]
    [(typed rmrs racket base date)
     current-milliseconds     current-seconds]]
   [(typed rmrs racket case eqv)
    case/eqv]
   [(typed rmrs racket promise lazy)
    lazy]
   [(typed rmrs racket unsafe ops data pair mutator)
    unsafe-set-immutable-car!
    unsafe-set-immutable-cdr!]]
  [(typed rmrs scheme)
   [(typed rmrs scheme base)
    [(typed rmrs scheme base condition)
     =>                       cond
     else                     unless
     when]
    [(typed rmrs scheme base continuation)
     call-with-current-continuation
     call/cc                  dynamic-wind]
    [(typed rmrs scheme base data)
     [(typed rmrs scheme base data boolean)
      and                      boolean=?
      boolean?                 not
      or]
     [(typed rmrs scheme base data character)
      char<=?                  char<?
      char=?                   char>=?
      char>?                   char?]
     [(typed rmrs scheme base data conversion)
      char->integer            integer->char
      list->string             list->vector
      number->string           string->list
      string->number           string->symbol
      symbol->string           vector->list]
     [(typed rmrs scheme base data list)
      append                   assoc
      assq                     assv
      car                      cdr
      cons                     for-each
      length                   list
      list-ref                 list-tail
      list?                    map
      member                   memq
      memv                     null?
      pair?                    reverse]
     [(typed rmrs scheme base data number)
      *                        +
      -                        /
      <                        <=
      =                        >
      >=                       abs
      ceiling                  complex?
      denominator              even?
      exact->inexact           exact-integer?
      exact?                   expt
      floor                    gcd
      inexact->exact           inexact?
      integer?                 lcm
      max                      min
      modulo                   negative?
      number?                  numerator
      odd?                     positive?
      quotient                 rational?
      rationalize              real?
      remainder                round
      truncate                 zero?]
     [(typed rmrs scheme base data string)
      [(typed rmrs scheme base data string base)
       make-string              string
       string-append            string-copy
       string-length            string-ref
       string<=?                string<?
       string=?                 string>=?
       string>?                 string?
       substring]
      [(typed rmrs scheme base data string mutator)
       string-copy!             string-fill!
       string-set!]]
     [(typed rmrs scheme base data symbol)
      symbol=?                 symbol?]
     [(typed rmrs scheme base data vector)
      [(typed rmrs scheme base data vector base)
       make-vector              vector
       vector-append            vector-copy
       vector-length            vector-ref
       vector?]
      [(typed rmrs scheme base data vector mutator)
       vector-copy!             vector-fill!
       vector-set!]]]
    [(typed rmrs scheme base exception)
     error                    raise]
    [(typed rmrs scheme base kernel)
     begin                    case-lambda
     define                   eq?
     equal?                   eqv?
     if                       lambda
     quasiquote               quote
     unquote                  unquote-splicing]
    [(typed rmrs scheme base let)
     let                      let*
     letrec                   letrec*]
    [(typed rmrs scheme base loop)
     do]
    [(typed rmrs scheme base macro)
     ...                      _
     define-syntax            let-syntax
     letrec-syntax            syntax-rules]
    [(typed rmrs scheme base mutator)
     set!]
    [(typed rmrs scheme base port)
     close-input-port         close-output-port
     current-error-port       current-input-port
     current-output-port      eof-object?
     get-output-string        input-port?
     newline                  open-input-string
     open-output-string       output-port?
     peek-char                port?
     read-char                read-line
     read-string              write-char
     write-string]
    [(typed rmrs scheme base procedure)
     apply                    procedure?]
    [(typed rmrs scheme base values)
     call-with-values         let-values
     let*-values              values]]
   [(typed rmrs scheme char)
    char-alphabetic?         char-ci<=?
    char-ci<?                char-ci=?
    char-ci>=?               char-ci>?
    char-downcase            char-foldcase
    char-lower-case?         char-numeric?
    char-upcase              char-upper-case?
    char-whitespace?         string-ci<=?
    string-ci<?              string-ci=?
    string-ci>=?             string-ci>?
    string-downcase          string-foldcase
    string-upcase]
   [(typed rmrs scheme complex)
    angle                    imag-part
    magnitude                make-polar
    make-rectangular         real-part]
   [(typed rmrs scheme cxr)
    caar                      cadr
    cdar                      cddr
    caaar                     caadr
    cadar                     caddr
    cdaar                     cdadr
    cddar                     cdddr
    caaaar                    caaadr
    caadar                    caaddr
    cadaar                    cadadr
    caddar                    cadddr
    cdaaar                    cdaadr
    cdadar                    cdaddr
    cddaar                    cddadr
    cdddar                    cddddr]
   [(typed rmrs scheme eval)
    eval                     interaction-environment]
   [(typed rmrs scheme file)
    call-with-input-file     call-with-output-file
    delete-file              file-exists?
    open-input-file          open-output-file
    with-input-from-file     with-output-to-file]
   [(typed rmrs scheme inexact)
    acos                     asin
    atan                     cos
    exp                      infinite?
    log                      nan?
    sin                      sqrt
    tan]
   [(typed rmrs scheme process-context)
    exit]
   [(typed rmrs scheme read)
    read]
   [(typed rmrs scheme write)
    display                  write]]
  [(typed rmrs srfi)
   [(typed rmrs srfi srfi-9)
    define-record-type]
   [(typed rmrs srfi srfi-155)
    delay                    delay-force
    force                    make-promise
    promise?]]]
#+end_src

** 第七版

#+begin_src racket
'[(typed rmrs)
  [(typed rmrs racket)
   [(typed rmrs racket base)
    [(typed rmrs racket base cmdline)
     current-command-line-arguments]
    [(typed rmrs racket base data)
     [(typed rmrs racket base data bytes)
      [(typed rmrs racket base data bytes base)
       bytes                    bytes-copy
       bytes-length             bytes-ref
       bytes?                   make-bytes]
      [(typed rmrs racket base data bytes conversion)
       string->bytes/utf-8      bytes->string/utf-8]
      [(typed rmrs racket base data bytes mutator)
       bytes-copy!              bytes-set!]]
     [(typed rmrs racket base data void)
      void                     void?]]
    [(typed rmrs racket base exception)
     call-with-exception-handler
     exn-irritants            exn-message
     exn:fail?                exn:fail:filesystem?
     exn:fail:read?           with-handlers
     with-handlers*]
    [(typed rmrs racket base kernel)
     :                        λ
     ann                      case-λ
     cast                     define-type]
    [(typed rmrs racket base port)
     eof                      flush-output
     get-output-bytes         open-input-bytes
     open-output-bytes        peek-byte
     port-closed?             read-bytes
     read-bytes!              read-byte
     string-port?             write-bytes
     write-byte]
    [(typed rmrs racket base date)
     current-milliseconds     current-seconds]]
   [(typed rmrs racket bool base)
    boolean=?                symbol=?]
   [(typed rmrs racket case eqv)
    case/eqv]
   [(typed rmrs racket promise lazy)
    lazy]
   [(typed rmrs racket math infnan)
    infinite?                nan?]
   [(typed rmrs racket unsafe ops data pair mutator)
    unsafe-set-immutable-car!
    unsafe-set-immutable-cdr!]
   [(typed rmrs racket vector base)
    vector-append            vector-copy]]
  [(typed rmrs scheme)
   [(typed rmrs scheme base)
    [(typed rmrs scheme base condition)
     =>                       cond
     else                     unless
     when]
    [(typed rmrs scheme base continuation)
     call-with-current-continuation
     call/cc                  dynamic-wind]
    [(typed rmrs scheme base data)
     [(typed rmrs scheme base data boolean)
      and                      boolean?
      not                      or]
     [(typed rmrs scheme base data character)
      char<=?                  char<?
      char=?                   char>=?
      char>?                   char?]
     [(typed rmrs scheme base data conversion)
      char->integer            integer->char
      list->string             list->vector
      number->string           string->list
      string->number           string->symbol
      symbol->string           vector->list]
     [(typed rmrs scheme base data list)
      append                   assoc
      assq                     assv
      car                      cdr
      cons                     for-each
      length                   list
      list-ref                 list-tail
      list?                    map
      member                   memq
      memv                     null?
      pair?                    reverse]
     [(typed rmrs scheme base data number)
      *                        +
      -                        /
      <                        <=
      =                        >
      >=                       abs
      ceiling                  complex?
      denominator              even?
      exact->inexact           exact-integer?
      exact?                   expt
      floor                    gcd
      inexact->exact           inexact?
      integer?                 lcm
      max                      min
      modulo                   negative?
      number?                  numerator
      odd?                     positive?
      quotient                 rational?
      rationalize              real?
      remainder                round
      truncate                 zero?]
     [(typed rmrs scheme base data string)
      [(typed rmrs scheme base data string base)
       make-string              string
       string-append            string-copy
       string-length            string-ref
       string<=?                string<?
       string=?                 string>=?
       string>?                 string?
       substring]
      [(typed rmrs scheme base data string mutator)
       string-copy!             string-fill!
       string-set!]]
     [(typed rmrs scheme base data symbol)
      symbol?]
     [(typed rmrs scheme base data vector)
      [(typed rmrs scheme base data vector base)
       make-vector              vector
       vector-length            vector-ref
       vector?]
      [(typed rmrs scheme base data vector mutator)
       vector-copy!             vector-fill!
       vector-set!]]]
    [(typed rmrs scheme base exception)
     error                    raise]
    [(typed rmrs scheme base kernel)
     begin                    case-lambda
     define                   eq?
     equal?                   eqv?
     if                       lambda
     quasiquote               quote
     unquote                  unquote-splicing]
    [(typed rmrs scheme base let)
     let                      let*
     letrec                   letrec*]
    [(typed rmrs scheme base loop)
     do]
    [(typed rmrs scheme base macro)
     ...                      _
     define-syntax            let-syntax
     letrec-syntax            syntax-rules]
    [(typed rmrs scheme base mutator)
     set!]
    [(typed rmrs scheme base port)
     close-input-port         close-output-port
     current-error-port       current-input-port
     current-output-port      eof-object?
     get-output-string        input-port?
     newline                  open-input-string
     open-output-string       output-port?
     peek-char                port?
     read-char                read-line
     read-string              write-char
     write-string]
    [(typed rmrs scheme base procedure)
     apply                    procedure?]
    [(typed rmrs scheme base values)
     call-with-values         let-values
     let*-values              values]]
   [(typed rmrs scheme char)
    char-alphabetic?         char-ci<=?
    char-ci<?                char-ci=?
    char-ci>=?               char-ci>?
    char-downcase            char-foldcase
    char-lower-case?         char-numeric?
    char-upcase              char-upper-case?
    char-whitespace?         string-ci<=?
    string-ci<?              string-ci=?
    string-ci>=?             string-ci>?
    string-downcase          string-foldcase
    string-upcase]
   [(typed rmrs scheme complex)
    angle                    imag-part
    magnitude                make-polar
    make-rectangular         real-part]
   [(typed rmrs scheme cxr)
    caar                      cadr
    cdar                      cddr
    caaar                     caadr
    cadar                     caddr
    cdaar                     cdadr
    cddar                     cdddr
    caaaar                    caaadr
    caadar                    caaddr
    cadaar                    cadadr
    caddar                    cadddr
    cdaaar                    cdaadr
    cdadar                    cdaddr
    cddaar                    cddadr
    cdddar                    cddddr]
   [(typed rmrs scheme eval)
    eval                     interaction-environment]
   [(typed rmrs scheme file)
    call-with-input-file     call-with-output-file
    delete-file              file-exists?
    open-input-file          open-output-file
    with-input-from-file     with-output-to-file]
   [(typed rmrs scheme inexact)
    acos                     asin
    atan                     cos
    exp                      log
    sin                      sqrt
    tan]
   [(typed rmrs scheme process-context)
    exit]
   [(typed rmrs scheme read)
    read]
   [(typed rmrs scheme write)
    display                  write]]
  [(typed rmrs srfi)
   [(typed rmrs srfi srfi-9)
    define-record-type]
   [(typed rmrs srfi srfi-155)
    delay                    delay-force
    force                    make-promise
    promise?]]]
#+end_src

* 附录
** 符号分类决策树

#+begin_example
                    符号 X
                      ↓
          Racket 和 Scheme 都有?
         /                     \
        是                      否
        ↓                       ↓
(typed rmrs scheme)           Racket 有?
                             /         \
                             是          否
                             ↓           ↓
                  (typed rmrs racket)  来自 SRFI?
                                       /         \
                                      是          否
                                      ↓           ↓
                             (typed rmrs srfi)  不导出
#+end_example

** 冲突处理策略

2. *同名异义* :: 优先采用 Racket 语义
3. *异名同义* :: 优先使用 Racket 名称
4. *避免冲突* :: 参考符号分类决策树，将冲突的符号放入 scheme 或 srfi 空间
